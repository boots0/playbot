const { SlashCommandBuilder, EmbedBuilder, MessageFlags } = require('discord.js');
const axios = require('axios');

// **NEW**: Core logic is now in its own function
async function generateReport(client) {
  const { SOURCE_CHANNEL_ID, OUTPUT_CHANNEL_ID, OPENAI_API_KEY } = process.env;

  if (!SOURCE_CHANNEL_ID || !OUTPUT_CHANNEL_ID || !OPENAI_API_KEY) {
    console.error('Bot is not fully configured for reports. Missing channel IDs or OpenAI key.');
    // In a non-interactive context, we can't reply, so we return an error status.
    return { success: false, message: 'Bot is not fully configured.' };
  }

  try {
    const sourceChannel = await client.channels.fetch(SOURCE_CHANNEL_ID);
    
    const sixHoursAgo = Date.now() - (6 * 60 * 60 * 1000);
    const messages = await sourceChannel.messages.fetch({ limit: 100 });
    const recentMessages = messages.filter(m => m.createdTimestamp > sixHoursAgo && !m.author.bot);

    if (recentMessages.size === 0) {
      console.log('Report run: No messages found in the last 6 hours.');
      return { success: true, message: 'No new messages to report.' };
    }
    
    const chatLog = recentMessages
      .sort((a, b) => a.createdTimestamp - b.createdTimestamp)
      .map(m => `${m.author.tag}: ${m.content} (link: ${m.url})`)
      .join('\n');
      
    const systemPrompt = `You are a trading analyst bot. Your task is to analyze a Discord chat log and extract all mentioned stock market plays. You must categorize them into "open_plays" and "closed_plays".

**Rules for Categorization:**
- A play is considered **closed** if it shows a profit/loss (e.g., "1.00 > 1.45", "closed for a loss") or uses words like 'closed', 'took profit', 'stopped out'.
- All other plays (e.g., "bought shares", "sold puts", "opening a position") are considered **open**.

**Output Requirements:**
- Your entire response MUST be a single, valid JSON object.
- The object must have two keys: "open_plays" and "closed_plays".
- Each key must contain an array of objects.
- Each object in the arrays must have two keys: "summary" (a short description of the play) and "link" (the URL provided with the message).
- If no plays are found in a category, the value should be an empty array [].

**Example of your required output format:**
{
  "open_plays": [
    {
      "summary": "Sold GLXY 32 CSP @ 3.10",
      "link": "https://discord.com/channels/..."
    }
  ],
  "closed_plays": [
    {
      "summary": "OPEN $2c 1.00 > 1.45",
      "link": "https://discord.com/channels/..."
    }
  ]
}`;
    
    const response = await axios.post('https://api.openai.com/v1/chat/completions', {
      model: 'gpt-4o',
      messages: [
        { role: 'system', content: systemPrompt },
        { role: 'user', content: chatLog }
      ],
      response_format: { type: "json_object" }
    }, {
      headers: {
        'Authorization': `Bearer ${OPENAI_API_KEY}`
      }
    });
    
    const aiResponse = response.data.choices[0].message.content;
    
    let plays;
    try {
      plays = JSON.parse(aiResponse);
    } catch (e) {
      console.error("Failed to parse JSON from AI:", aiResponse);
      return { success: false, message: 'AI returned an invalid response.' };
    }

    const { open_plays = [], closed_plays = [] } = plays;

    if (open_plays.length === 0 && closed_plays.length === 0) {
      console.log('Report run: No new plays were found in the chat log.');
      return { success: true, message: 'No new plays found.' };
    }

    const outputChannel = await client.channels.fetch(OUTPUT_CHANNEL_ID);
    
    const reportEmbed = new EmbedBuilder()
      .setTitle('Recent Plays Report')
      .setColor('#5865F2')
      .setTimestamp()
      .setFooter({ text: `Generated by Moja | Scraped from #${sourceChannel.name}` });

    if (open_plays.length > 0) {
      const openPlaysText = open_plays
        .map(p => `‚Ä¢ ${p.summary} - [Link](${p.link})`)
        .join('\n');
      reportEmbed.addFields({ 
        name: 'üìä New Plays', 
        value: openPlaysText,
        inline: false
      });
    }

    if (closed_plays.length > 0) {
      const closedPlaysText = closed_plays
        .map(p => `‚Ä¢ ${p.summary} - [Link](${p.link})`)
        .join('\n');
      reportEmbed.addFields({ 
        name: '‚úÖ Closed Positions', 
        value: closedPlaysText,
        inline: false
      });
    }

    await outputChannel.send({ embeds: [reportEmbed] });
    return { success: true, message: `Report generated and posted to #${outputChannel.name}.` };

  } catch (error) {
    console.error('Error during report generation:', error.response ? error.response.data : error.message);
    return { success: false, message: 'An error occurred during report generation.' };
  }
}

module.exports = {
  data: new SlashCommandBuilder()
    .setName('report')
    .setDescription('Scrapes recent chat for plays and organizes them into a summary.'),

  async execute(interaction) {
    await interaction.deferReply({ flags: MessageFlags.Ephemeral });

    if (interaction.user.id !== process.env.ADMIN_USER_ID) {
      return interaction.editReply({ content: '‚ùå You do not have permission to use this command.' });
    }
    
    // The slash command now just calls the main logic function
    const result = await generateReport(interaction.client);

    if (result.success) {
      return interaction.editReply(`‚úÖ ${result.message}`);
    } else {
      return interaction.editReply(`‚ùå ${result.message}`);
    }
  },
  // Export the new function so we can call it from our server
  generateReport,
};
